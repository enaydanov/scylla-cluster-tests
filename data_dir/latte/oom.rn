use latte::*;

const TOTAL_ROWS = latte::param!("rows", 10_000_000);
const RF = latte::param!("replication_factor", 3);
const KS = latte::param!("keyspace", "oom");
const TABLE = latte::param!("table", "tbl");
const TABLE_COUNT = latte::param!("table_count", 2000);
const ROWS_PER_PARTITION = latte::param!("rows_per_partition", 1000);
const PARTITION_SIZES = "100:1";

pub async fn schema(db) {
    db.execute(`
        CREATE KEYSPACE IF NOT EXISTS ${KS}
        WITH replication = {
          'class'              : 'NetworkTopologyStrategy',
          'replication_factor' : ${RF}
        }
    `).await?;

    db.execute(`
        CREATE TABLE IF NOT EXISTS ${KS}.${TABLE} (
            pk bigint,
            ck bigint,
            a int,
            pad text,
            PRIMARY KEY (pk, ck)
        )
    `).await?;

    for i in 0..=TABLE_COUNT-1 {
        db.execute(`
            CREATE TABLE IF NOT EXISTS ${KS}.${TABLE}___________________________________________${i} (
                pk bigint,
                ck bigint,
                a int,
                pad text,
                PRIMARY KEY (pk, ck)
            )
        `).await?;
    }
}

pub async fn prepare(db) {
    db.init_partition_row_distribution_preset(
        "main", TOTAL_ROWS, ROWS_PER_PARTITION, PARTITION_SIZES,
    ).await?;

    db.prepare(
        "insert",
        `INSERT INTO ${KS}.${TABLE} (pk, ck, a, pad) VALUES (?, ?, ?, ?)`
    ).await?;

    db.prepare(
        "select",
        `SELECT a, pad FROM ${KS}.${TABLE} WHERE pk = ? AND ck = ?`
    ).await?;
}

fn pad(i) {
    latte::text(i, 200)
}

pub async fn write(db, i) {
    let partition = db.get_partition_info("main", i).await;
    let pk = hash(partition.idx);
    let ck = hash(i);
    let a  = hash_range(i, 1_000_000);

    db.execute_prepared("insert", [pk, ck, a, pad(i)]).await
}

pub async fn read(db, i) {
    let partition = db.get_partition_info("main", i).await;
    let pk = hash(partition.idx);
    let ck = hash(i);
    db.execute_prepared("select", [pk, ck]).await
}
